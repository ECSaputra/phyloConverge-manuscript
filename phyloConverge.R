source("misc_functions.R")
require("rphast")


#'Computes bias-corrected conservation/acceleration score of a given feature using maximum likelihood estimation of branch scaling and phylogenetic permulations (phylogeny-aware permutation test)
#' @param feature a feature object containing information on chromosome, coordinates, and name of the feature to be scored
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param maf an MSA object containing the sequence alignment
#' @param neutralMod neutral nucleutide substitution model
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out a data frame containing phyloConverge permulation p-values, corrected score, and uncorrected score (negative score denotes acceleration, positive score denotes deceleration)
#' @export
phyloConverge=function(feature, foregrounds, permulated_foregrounds, maf, neutralMod, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
        ### observed phyloP score
        fg_exist = checkForegrounds(maf, foregrounds)
        if (length(fg_exist) >= min.fg){
                observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
                observed.score = observed.score$score
                
                if (adapt){
                        max_permulations = length(permulated_foregrounds)
                        maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
                        
                        permulated_scores = rep(NA, length(permulated_foregrounds))
                        
                        for (i in 1:length(permulated_foregrounds)){
                                fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
                                if (length(fg_exist) >= min.fg){
                                        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
                                        permulated_scores[i] = permulated_score_i$score
                                        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
                                        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
                                                median_null_scores = median(computed_permulated_scores)
                                                
                                                if (observed.score <= median_null_scores){
                                                        one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
                                                        ind_nonextreme = which(one_sided_null_scores > observed.score)
                                                        ind_extreme = which(one_sided_null_scores <= observed.score)
                                                } else if (observed.score > median_null_scores){
                                                        one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
                                                        ind_nonextreme = which(one_sided_null_scores < observed.score)
                                                        ind_extreme = which(one_sided_null_scores >= observed.score)
                                                }
                                                
                                                if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
                                                        permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
                                                        corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
                                                        break
                                                }
                                        }
                                }
                        }
                } else {
                        permulated_scores = rep(NA, length(permulated_foregrounds))
                        for (i in 1:length(permulated_foregrounds)){
                                fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
                                if (length(fg_exist) >= min.fg){
                                        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
                                        permulated_scores[i] = permulated_score_i$score
                                }
                        }
                        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
                        
                        median_null_scores = median(computed_permulated_scores)
                        if (observed.score <= median_null_scores){
                                one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
                                ind_extreme = which(one_sided_null_scores <= observed.score)
                        } else if (observed.score > median_null_scores){
                                one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
                                ind_extreme = which(one_sided_null_scores >= observed.score)
                        }
                        
                        permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
                        corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
                }
        } else {
                permPval = NA
                observed.score = NA
                corr_score = NA
        }
        
        out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
        out
}


#'Scan nucleotides in a multiple sequence alignment and compute bias-corrected conservation/acceleration score using phyloConverge
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param refseq reference species in the alignment (e.g., "mm10")
#' @param offset offset value of the alignment (default 0)
#' @param stride step size defining intervals between positions being scored in the alignment (default 1)
#' @param window odd number defining the window size used for each score computed (default 1)
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out_df a data frame containing phyloConverge permulation p-values, corrected score, and uncorrected score for each position (negative score denotes acceleration, positive score denotes deceleration)
#' @export
scanWithPhyloConverge=function(maf, foregrounds, permulated_foregrounds, neutralMod, refseq, offset=0, stride=1, window=1, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
	coord_range = coord.range.msa(maf)
	
	flank = (window-1)/2
	start_pos = (window-1)/2 + 1
	scored_pos = seq(start_pos, coord_range[2], stride)
	
	bed_table = data.frame("chr"=rep("null", length(scored_pos)), "start"=scored_pos-flank, "end"=scored_pos-flank, "pos"=as.character(scored_pos))
	featureout = convertBedToFeature(bed_table, refseq)
	
	scan_score = rep(NA, nrow(featureout))
	for (i in 1:nrow(featureout)){
		print(i)
		score_i = phyloConverge(featureout[i,], foregrounds, permulated_foregrounds, maf, neutralMod, alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
		scan_score[i] = score_i$corr_score	
	}
	position = offset + scored_pos
	
	out_df = data.frame("coordinate"=position, "corr_score"=scan_score)
	out_df
}

